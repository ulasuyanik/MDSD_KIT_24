/*
 * generated by Xtext 2.34.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import mdsd.component_based.Component_basedPackage;
import mdsd.component_based.EAllocationContext;
import mdsd.component_based.EAllocationViewType;
import mdsd.component_based.EAssemblyConnector;
import mdsd.component_based.EAssemblyContext;
import mdsd.component_based.EAssemblyViewPoint;
import mdsd.component_based.EAssemblyViewType;
import mdsd.component_based.EBehaviourDescription;
import mdsd.component_based.EBranch;
import mdsd.component_based.EComponent;
import mdsd.component_based.ECompositeComponent;
import mdsd.component_based.EContainer;
import mdsd.component_based.EDeploymentViewPoint;
import mdsd.component_based.EEnvironmentViewType;
import mdsd.component_based.EExternalCall;
import mdsd.component_based.EInterface;
import mdsd.component_based.EInternalAction;
import mdsd.component_based.ELink;
import mdsd.component_based.ELoop;
import mdsd.component_based.EParameter;
import mdsd.component_based.EProvidedDelegationConnector;
import mdsd.component_based.EProvidedRole;
import mdsd.component_based.ERepository;
import mdsd.component_based.ERepositoryViewType;
import mdsd.component_based.ERequiredDelegationConnector;
import mdsd.component_based.ERequiredRole;
import mdsd.component_based.ERoot;
import mdsd.component_based.EService;
import mdsd.component_based.ESignature;
import mdsd.component_based.ESystem;
import mdsd.component_based.ESystemIndependentViewPoint;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Component_basedPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Component_basedPackage.EALLOCATION_CONTEXT:
				sequence_EAllocationContext(context, (EAllocationContext) semanticObject); 
				return; 
			case Component_basedPackage.EALLOCATION_VIEW_TYPE:
				sequence_EAllocationViewType(context, (EAllocationViewType) semanticObject); 
				return; 
			case Component_basedPackage.EASSEMBLY_CONNECTOR:
				sequence_EAssemblyConnector(context, (EAssemblyConnector) semanticObject); 
				return; 
			case Component_basedPackage.EASSEMBLY_CONTEXT:
				sequence_EAssemblyContext(context, (EAssemblyContext) semanticObject); 
				return; 
			case Component_basedPackage.EASSEMBLY_VIEW_POINT:
				sequence_EAssemblyViewPoint(context, (EAssemblyViewPoint) semanticObject); 
				return; 
			case Component_basedPackage.EASSEMBLY_VIEW_TYPE:
				sequence_EAssemblyViewType(context, (EAssemblyViewType) semanticObject); 
				return; 
			case Component_basedPackage.EBEHAVIOUR_DESCRIPTION:
				sequence_EBehaviourDescription(context, (EBehaviourDescription) semanticObject); 
				return; 
			case Component_basedPackage.EBRANCH:
				sequence_EBranch(context, (EBranch) semanticObject); 
				return; 
			case Component_basedPackage.ECOMPONENT:
				sequence_EComponent_Impl(context, (EComponent) semanticObject); 
				return; 
			case Component_basedPackage.ECOMPOSITE_COMPONENT:
				sequence_ECompositeComponent(context, (ECompositeComponent) semanticObject); 
				return; 
			case Component_basedPackage.ECONTAINER:
				sequence_EContainer(context, (EContainer) semanticObject); 
				return; 
			case Component_basedPackage.EDEPLOYMENT_VIEW_POINT:
				sequence_EDeploymentViewPoint(context, (EDeploymentViewPoint) semanticObject); 
				return; 
			case Component_basedPackage.EENVIRONMENT_VIEW_TYPE:
				sequence_EEnvironmentViewType(context, (EEnvironmentViewType) semanticObject); 
				return; 
			case Component_basedPackage.EEXTERNAL_CALL:
				sequence_EExternalCall(context, (EExternalCall) semanticObject); 
				return; 
			case Component_basedPackage.EINTERFACE:
				sequence_EInterface(context, (EInterface) semanticObject); 
				return; 
			case Component_basedPackage.EINTERNAL_ACTION:
				sequence_EInternalAction(context, (EInternalAction) semanticObject); 
				return; 
			case Component_basedPackage.ELINK:
				sequence_ELink(context, (ELink) semanticObject); 
				return; 
			case Component_basedPackage.ELOOP:
				sequence_ELoop(context, (ELoop) semanticObject); 
				return; 
			case Component_basedPackage.EPARAMETER:
				sequence_EParameter(context, (EParameter) semanticObject); 
				return; 
			case Component_basedPackage.EPROVIDED_DELEGATION_CONNECTOR:
				sequence_EProvidedDelegationConnector(context, (EProvidedDelegationConnector) semanticObject); 
				return; 
			case Component_basedPackage.EPROVIDED_ROLE:
				sequence_EProvidedRole(context, (EProvidedRole) semanticObject); 
				return; 
			case Component_basedPackage.EREPOSITORY:
				sequence_ERepository(context, (ERepository) semanticObject); 
				return; 
			case Component_basedPackage.EREPOSITORY_VIEW_TYPE:
				sequence_ERepositoryViewType(context, (ERepositoryViewType) semanticObject); 
				return; 
			case Component_basedPackage.EREQUIRED_DELEGATION_CONNECTOR:
				sequence_ERequiredDelegationConnector(context, (ERequiredDelegationConnector) semanticObject); 
				return; 
			case Component_basedPackage.EREQUIRED_ROLE:
				sequence_ERequiredRole(context, (ERequiredRole) semanticObject); 
				return; 
			case Component_basedPackage.EROOT:
				sequence_ERoot(context, (ERoot) semanticObject); 
				return; 
			case Component_basedPackage.ESERVICE:
				sequence_EService(context, (EService) semanticObject); 
				return; 
			case Component_basedPackage.ESIGNATURE:
				sequence_ESignature(context, (ESignature) semanticObject); 
				return; 
			case Component_basedPackage.ESYSTEM:
				sequence_ESystem(context, (ESystem) semanticObject); 
				return; 
			case Component_basedPackage.ESYSTEM_INDEPENDENT_VIEW_POINT:
				sequence_ESystemIndependentViewPoint(context, (ESystemIndependentViewPoint) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     EAllocationContext returns EAllocationContext
	 *
	 * Constraint:
	 *     ((controls+=[EContainer|ID] controls+=[EContainer|ID]*)? specifiesFor+=[ESystem|ID] specifiesFor+=[ESystem|ID]* specifies=[EAssemblyContext|ID])
	 * </pre>
	 */
	protected void sequence_EAllocationContext(ISerializationContext context, EAllocationContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EViewType returns EAllocationViewType
	 *     EAllocationViewType returns EAllocationViewType
	 *
	 * Constraint:
	 *     (includes+=EAllocationContext includes+=EAllocationContext*)?
	 * </pre>
	 */
	protected void sequence_EAllocationViewType(ISerializationContext context, EAllocationViewType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EAssemblyConnector returns EAssemblyConnector
	 *
	 * Constraint:
	 *     (name=EString linkTo=[ERequiredRole|ID] linkFrom=[EProvidedRole|ID])
	 * </pre>
	 */
	protected void sequence_EAssemblyConnector(ISerializationContext context, EAssemblyConnector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.EASSEMBLY_CONNECTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.EASSEMBLY_CONNECTOR__NAME));
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.EASSEMBLY_CONNECTOR__LINK_TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.EASSEMBLY_CONNECTOR__LINK_TO));
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.EASSEMBLY_CONNECTOR__LINK_FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.EASSEMBLY_CONNECTOR__LINK_FROM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEAssemblyConnectorAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEAssemblyConnectorAccess().getLinkToERequiredRoleIDTerminalRuleCall_4_1_0_1(), semanticObject.eGet(Component_basedPackage.Literals.EASSEMBLY_CONNECTOR__LINK_TO, false));
		feeder.accept(grammarAccess.getEAssemblyConnectorAccess().getLinkFromEProvidedRoleIDTerminalRuleCall_5_1_0_1(), semanticObject.eGet(Component_basedPackage.Literals.EASSEMBLY_CONNECTOR__LINK_FROM, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EAssemblyContext returns EAssemblyContext
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         allocated=[EContainer|ID]? 
	 *         (encapsulatedByComponent+=[ECompositeComponent|ID] encapsulatedByComponent+=[ECompositeComponent|ID]*)? 
	 *         (encapsulatedBySystem+=[ESystem|ID] encapsulatedBySystem+=[ESystem|ID]*)? 
	 *         (instantiates+=[EComponent|ID] instantiates+=[EComponent|ID]*)? 
	 *         (roles+=ERole roles+=ERole*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_EAssemblyContext(ISerializationContext context, EAssemblyContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EViewPoint returns EAssemblyViewPoint
	 *     EAssemblyViewPoint returns EAssemblyViewPoint
	 *
	 * Constraint:
	 *     assemblyViewType=EAssemblyViewType
	 * </pre>
	 */
	protected void sequence_EAssemblyViewPoint(ISerializationContext context, EAssemblyViewPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.EASSEMBLY_VIEW_POINT__ASSEMBLY_VIEW_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.EASSEMBLY_VIEW_POINT__ASSEMBLY_VIEW_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEAssemblyViewPointAccess().getAssemblyViewTypeEAssemblyViewTypeParserRuleCall_3_1_0(), semanticObject.getAssemblyViewType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EViewType returns EAssemblyViewType
	 *     EAssemblyViewType returns EAssemblyViewType
	 *
	 * Constraint:
	 *     ((mainArtifacts+=EAssemblyContext mainArtifacts+=EAssemblyContext*)? (showsComponents+=[EComponent|ID] showsComponents+=[EComponent|ID]*)?)
	 * </pre>
	 */
	protected void sequence_EAssemblyViewType(ISerializationContext context, EAssemblyViewType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EBehaviourDescription returns EBehaviourDescription
	 *
	 * Constraint:
	 *     (
	 *         (internalAction+=EInternalAction internalAction+=EInternalAction*)? 
	 *         (loop+=ELoop loop+=ELoop*)? 
	 *         (branch+=EBranch branch+=EBranch*)? 
	 *         (externalCall+=EExternalCall externalCall+=EExternalCall*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_EBehaviourDescription(ISerializationContext context, EBehaviourDescription semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EBranch returns EBranch
	 *
	 * Constraint:
	 *     {EBranch}
	 * </pre>
	 */
	protected void sequence_EBranch(ISerializationContext context, EBranch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EComponent returns EComponent
	 *     EComponent_Impl returns EComponent
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (providesInterfaceTo+=[EComponent|EString] providesInterfaceTo+=[EComponent|EString]*)? 
	 *         (usesInterfaceFrom+=[EComponent|EString] usesInterfaceFrom+=[EComponent|EString]*)? 
	 *         (providesDirectly+=[EService|EString] providesDirectly+=[EService|EString]*)? 
	 *         (provides+=[EInterface|EString] provides+=[EInterface|EString]*)? 
	 *         (requires+=[EInterface|EString] requires+=[EInterface|EString]*)? 
	 *         behaviourDescription=EBehaviourDescription?
	 *     )
	 * </pre>
	 */
	protected void sequence_EComponent_Impl(ISerializationContext context, EComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ECompositeComponent returns ECompositeComponent
	 *     EComponent returns ECompositeComponent
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (providesInterfaceTo+=[EComponent|ID] providesInterfaceTo+=[EComponent|ID]*)? 
	 *         (usesInterfaceFrom+=[EComponent|ID] usesInterfaceFrom+=[EComponent|ID]*)? 
	 *         (providesDirectly+=[EService|ID] providesDirectly+=[EService|ID]*)? 
	 *         (provides+=[EInterface|ID] provides+=[EInterface|ID]*)? 
	 *         (requires+=[EInterface|ID] requires+=[EInterface|ID]*)? 
	 *         (encapsulates+=[EAssemblyContext|ID] encapsulates+=[EAssemblyContext|ID]*)? 
	 *         behaviourDescription=EBehaviourDescription?
	 *     )
	 * </pre>
	 */
	protected void sequence_ECompositeComponent(ISerializationContext context, ECompositeComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EContainer returns EContainer
	 *
	 * Constraint:
	 *     (name=EString (connectedTo+=[ELink|ID] connectedTo+=[ELink|ID]*)?)
	 * </pre>
	 */
	protected void sequence_EContainer(ISerializationContext context, EContainer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EViewPoint returns EDeploymentViewPoint
	 *     EDeploymentViewPoint returns EDeploymentViewPoint
	 *
	 * Constraint:
	 *     (allocationViewType=EAllocationViewType environmentViewType=EEnvironmentViewType)
	 * </pre>
	 */
	protected void sequence_EDeploymentViewPoint(ISerializationContext context, EDeploymentViewPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.EDEPLOYMENT_VIEW_POINT__ALLOCATION_VIEW_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.EDEPLOYMENT_VIEW_POINT__ALLOCATION_VIEW_TYPE));
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.EDEPLOYMENT_VIEW_POINT__ENVIRONMENT_VIEW_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.EDEPLOYMENT_VIEW_POINT__ENVIRONMENT_VIEW_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEDeploymentViewPointAccess().getAllocationViewTypeEAllocationViewTypeParserRuleCall_4_0(), semanticObject.getAllocationViewType());
		feeder.accept(grammarAccess.getEDeploymentViewPointAccess().getEnvironmentViewTypeEEnvironmentViewTypeParserRuleCall_6_0(), semanticObject.getEnvironmentViewType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EViewType returns EEnvironmentViewType
	 *     EEnvironmentViewType returns EEnvironmentViewType
	 *
	 * Constraint:
	 *     ((showsLinks+=[ELink|ID] showsLinks+=[ELink|ID]*)? (showsContainers+=[EContainer|ID] showsContainers+=[EContainer|ID]*)?)
	 * </pre>
	 */
	protected void sequence_EEnvironmentViewType(ISerializationContext context, EEnvironmentViewType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EExternalCall returns EExternalCall
	 *
	 * Constraint:
	 *     to=[EService|EString]
	 * </pre>
	 */
	protected void sequence_EExternalCall(ISerializationContext context, EExternalCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.EEXTERNAL_CALL__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.EEXTERNAL_CALL__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEExternalCallAccess().getToEServiceEStringParserRuleCall_3_1_0_1(), semanticObject.eGet(Component_basedPackage.Literals.EEXTERNAL_CALL__TO, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EInterface returns EInterface
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (resultsIn+=[ERole|EString] resultsIn+=[ERole|EString]*)? 
	 *         (providedByComponent+=[EComponent|EString] providedByComponent+=[EComponent|EString]*)? 
	 *         (providedBySystem+=[ESystem|EString] providedBySystem+=[ESystem|EString]*)? 
	 *         (requiredByComponent+=[EComponent|EString] requiredByComponent+=[EComponent|EString]*)? 
	 *         (requiredBySystem+=[ESystem|EString] requiredBySystem+=[ESystem|EString]*)? 
	 *         (signature+=ESignature signature+=ESignature*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_EInterface(ISerializationContext context, EInterface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EInternalAction returns EInternalAction
	 *
	 * Constraint:
	 *     {EInternalAction}
	 * </pre>
	 */
	protected void sequence_EInternalAction(ISerializationContext context, EInternalAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ELink returns ELink
	 *
	 * Constraint:
	 *     (name=EString connects+=[EContainer|ID] connects+=[EContainer|ID]+)
	 * </pre>
	 */
	protected void sequence_ELink(ISerializationContext context, ELink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ELoop returns ELoop
	 *
	 * Constraint:
	 *     {ELoop}
	 * </pre>
	 */
	protected void sequence_ELoop(ISerializationContext context, ELoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EParameter returns EParameter
	 *
	 * Constraint:
	 *     (name=EString type=PossibleParameterTypes)
	 * </pre>
	 */
	protected void sequence_EParameter(ISerializationContext context, EParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.EPARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.EPARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.EPARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.EPARAMETER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEParameterAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEParameterAccess().getTypePossibleParameterTypesEnumRuleCall_4_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EProvidedDelegationConnector returns EProvidedDelegationConnector
	 *     EDelegationConnector returns EProvidedDelegationConnector
	 *
	 * Constraint:
	 *     (linkFrom=[EInterface|ID] linkTo=[EProvidedRole|ID])
	 * </pre>
	 */
	protected void sequence_EProvidedDelegationConnector(ISerializationContext context, EProvidedDelegationConnector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.EPROVIDED_DELEGATION_CONNECTOR__LINK_FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.EPROVIDED_DELEGATION_CONNECTOR__LINK_FROM));
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.EPROVIDED_DELEGATION_CONNECTOR__LINK_TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.EPROVIDED_DELEGATION_CONNECTOR__LINK_TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEProvidedDelegationConnectorAccess().getLinkFromEInterfaceIDTerminalRuleCall_3_1_0_1(), semanticObject.eGet(Component_basedPackage.Literals.EPROVIDED_DELEGATION_CONNECTOR__LINK_FROM, false));
		feeder.accept(grammarAccess.getEProvidedDelegationConnectorAccess().getLinkToEProvidedRoleIDTerminalRuleCall_4_1_0_1(), semanticObject.eGet(Component_basedPackage.Literals.EPROVIDED_DELEGATION_CONNECTOR__LINK_TO, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ERole returns EProvidedRole
	 *     EProvidedRole returns EProvidedRole
	 *
	 * Constraint:
	 *     (name=EString roleOf=[EAssemblyContext|ID]? linkedFrom=[EAssemblyConnector|ID]?)
	 * </pre>
	 */
	protected void sequence_EProvidedRole(ISerializationContext context, EProvidedRole semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EViewType returns ERepositoryViewType
	 *     ERepositoryViewType returns ERepositoryViewType
	 *
	 * Constraint:
	 *     ((showsInterfaces+=[EInterface|ID] showsInterfaces+=[EInterface|ID]*)? (showsComponents+=[EComponent|ID] showsComponents+=[EComponent|ID]*)?)
	 * </pre>
	 */
	protected void sequence_ERepositoryViewType(ISerializationContext context, ERepositoryViewType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ERepository returns ERepository
	 *
	 * Constraint:
	 *     ((component+=EComponent component+=EComponent*)? (interface+=EInterface interface+=EInterface*)?)
	 * </pre>
	 */
	protected void sequence_ERepository(ISerializationContext context, ERepository semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ERequiredDelegationConnector returns ERequiredDelegationConnector
	 *     EDelegationConnector returns ERequiredDelegationConnector
	 *
	 * Constraint:
	 *     (linkFrom=[ERequiredRole|ID] linkTo=[EInterface|ID])
	 * </pre>
	 */
	protected void sequence_ERequiredDelegationConnector(ISerializationContext context, ERequiredDelegationConnector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.EREQUIRED_DELEGATION_CONNECTOR__LINK_FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.EREQUIRED_DELEGATION_CONNECTOR__LINK_FROM));
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.EREQUIRED_DELEGATION_CONNECTOR__LINK_TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.EREQUIRED_DELEGATION_CONNECTOR__LINK_TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getERequiredDelegationConnectorAccess().getLinkFromERequiredRoleIDTerminalRuleCall_3_1_0_1(), semanticObject.eGet(Component_basedPackage.Literals.EREQUIRED_DELEGATION_CONNECTOR__LINK_FROM, false));
		feeder.accept(grammarAccess.getERequiredDelegationConnectorAccess().getLinkToEInterfaceIDTerminalRuleCall_4_1_0_1(), semanticObject.eGet(Component_basedPackage.Literals.EREQUIRED_DELEGATION_CONNECTOR__LINK_TO, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ERole returns ERequiredRole
	 *     ERequiredRole returns ERequiredRole
	 *
	 * Constraint:
	 *     (name=EString roleOf=[EAssemblyContext|ID]? linkedTo=[EAssemblyConnector|ID]?)
	 * </pre>
	 */
	protected void sequence_ERequiredRole(ISerializationContext context, ERequiredRole semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ERoot returns ERoot
	 *
	 * Constraint:
	 *     (
	 *         (eviewpoint+=EViewPoint eviewpoint+=EViewPoint*)? 
	 *         (eviewtype+=EViewType eviewtype+=EViewType*)? 
	 *         (eparameter+=EParameter eparameter+=EParameter*)? 
	 *         (esignature+=ESignature esignature+=ESignature*)? 
	 *         (edelegationconnector+=EDelegationConnector edelegationconnector+=EDelegationConnector*)? 
	 *         (erole+=ERole erole+=ERole*)? 
	 *         (elink+=ELink elink+=ELink*)? 
	 *         (econtainer+=EContainer econtainer+=EContainer*)? 
	 *         (eassemblyconnector+=EAssemblyConnector eassemblyconnector+=EAssemblyConnector*)? 
	 *         (eassemblycontext+=EAssemblyContext eassemblycontext+=EAssemblyContext*)? 
	 *         (ecomponent+=EComponent ecomponent+=EComponent*)? 
	 *         (eservice+=EService eservice+=EService*)? 
	 *         (einterface+=EInterface einterface+=EInterface*)? 
	 *         (esystem+=ESystem esystem+=ESystem*)? 
	 *         (erepository+=ERepository erepository+=ERepository*)? 
	 *         (ebehaviourdescription+=EBehaviourDescription ebehaviourdescription+=EBehaviourDescription*)? 
	 *         (eexternalcall+=EExternalCall eexternalcall+=EExternalCall*)? 
	 *         (einternalaction+=EInternalAction einternalaction+=EInternalAction*)? 
	 *         (ebranch+=EBranch ebranch+=EBranch*)? 
	 *         (eloop+=ELoop eloop+=ELoop*)? 
	 *         (ecompositecomponent+=ECompositeComponent ecompositecomponent+=ECompositeComponent*)? 
	 *         (eallocationcontext+=EAllocationContext eallocationcontext+=EAllocationContext*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_ERoot(ISerializationContext context, ERoot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EService returns EService
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_EService(ISerializationContext context, EService semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.ESERVICE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.ESERVICE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEServiceAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ESignature returns ESignature
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         returnType=PossibleReturnTypes 
	 *         (correspondsTo+=[EService|EString] correspondsTo+=[EService|EString]*)? 
	 *         (parameter+=EParameter parameter+=EParameter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_ESignature(ISerializationContext context, ESignature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EViewPoint returns ESystemIndependentViewPoint
	 *     ESystemIndependentViewPoint returns ESystemIndependentViewPoint
	 *
	 * Constraint:
	 *     repositoryViewType=ERepositoryViewType
	 * </pre>
	 */
	protected void sequence_ESystemIndependentViewPoint(ISerializationContext context, ESystemIndependentViewPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Component_basedPackage.Literals.ESYSTEM_INDEPENDENT_VIEW_POINT__REPOSITORY_VIEW_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Component_basedPackage.Literals.ESYSTEM_INDEPENDENT_VIEW_POINT__REPOSITORY_VIEW_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getESystemIndependentViewPointAccess().getRepositoryViewTypeERepositoryViewTypeParserRuleCall_3_1_0(), semanticObject.getRepositoryViewType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ESystem returns ESystem
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         provides+=[EInterface|ID] 
	 *         provides+=[EInterface|ID]* 
	 *         (requires+=[EInterface|ID] requires+=[EInterface|ID]*)? 
	 *         (encapsulates+=[EAssemblyContext|ID] encapsulates+=[EAssemblyContext|ID]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_ESystem(ISerializationContext context, ESystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
